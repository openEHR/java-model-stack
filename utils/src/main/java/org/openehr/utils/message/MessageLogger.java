/*
 * #%L
 * OpenEHR - Java Model Stack
 * %%
 * Copyright (C) 2016 - 2017  Cognitive Medical Systems, Inc (http://www.cognitivemedicine.com).
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 * Author: Claude Nanjo
 */
package org.openehr.utils.message;

import java.util.ArrayList;
import java.util.List;

/**
 * A cache of debug-, info-, warning-, or error-level messages that are generated by a process such as
 * the validation of an OpenEHR model load and configuration.
 *
 */
public class MessageLogger {

    /**
     * Error output of validator - things that must be corrected
     */
    private List<MessageDescriptor> messageList = new ArrayList<>();
    private boolean hasErrors;
    private boolean hasWarnings;
    private boolean hasInfo;
    private MessageDatabaseManager messageDatabaseManager = MessageDatabaseManager.getInstance();

    /**
     * Returns the last message added to the error cache.
     *
     * @return
     */
    public MessageDescriptor lastAdded() {
        if(messageList != null && messageList.size() > 0) {
            return messageList.get(messageList.size() - 1);
        } else {
            return null;
        }
    }

    /**
     * Returns all messages of type ERROR_TYPE_ERROR.
     *
     * @return
     */
    public List<String> getErrorCodes() {
        List<String> errorCodes = new ArrayList<>();
        messageList.forEach(item -> {
            if(item.getSeverity().equals(MessageSeverityTypes.ERROR_TYPE_ERROR)) {
                errorCodes.add(item.getCode());
            }
        });
        return errorCodes;
    }

    /**
     * Returns all messages of type ERROR_TYPE_WARNING
     *
     * @return
     */
    public List<String> getWarningCodes() {
        List<String> warningCodes = new ArrayList<>();
        messageList.forEach(item -> {
            if(item.getSeverity().equals(MessageSeverityTypes.ERROR_TYPE_WARNING)) {
                warningCodes.add(item.getCode());
            }
        });
        return warningCodes;
    }

    /**
     * Returns all messages of type ERROR_TYPE_INFO
     *
     * @return
     */
    public List<String> getInfoCodes() {
        List<String> infoCodes = new ArrayList<>();
        messageList.forEach(item -> {
            if(item.getSeverity().equals(MessageSeverityTypes.ERROR_TYPE_INFO)) {
                infoCodes.add(item.getCode());
            }
        });
        return infoCodes;
    }

    /**
     * Returns true if this error cache is empty.
     *
     * @return
     */
    public boolean isEmpty() {
        return messageList.isEmpty();
    }

    /**
     * Returns true if this error cache has errors
     *
     * @return
     */
    public boolean hasErrors() {
        return hasErrors;
    }

    /**
     * Returns true if this error cache has warnings.
     *
     * @return
     */
    public boolean hasWarnings() {
        return hasWarnings;
    }

    /**
     * Returns true if this error cache has info-level messages.
     *
     * @return
     */
    public boolean hasInfo() {
        return hasInfo;
    }

    /**
     * Returns true if this error cache has either error or warning messages.
     *
     * @return
     */
    public boolean hasErrorsOrWarnings() {
        return hasErrors || hasWarnings;
    }

    /**
     * True if there has been an error recorded with code `a_code'
     *
     * @param aCode
     * @return
     */
    public boolean hasError(String aCode) {
        return getErrorCodes().contains(aCode);
    }

    /**
     * True if there has been an error recorded with code `a_code'
     *
     * @param aCode
     * @return
     */
    public boolean hasWarning(String aCode) {
        return getWarningCodes().contains(aCode);
    }

    /**
     * True if there has been an error recorded with code `a_code'
     *
     * @param aCode
     * @return
     */
    public boolean hasInfo(String aCode) {
        return getInfoCodes().contains(aCode);
    }

    /**
     * True if there has been an error whose code starts with code `a_code'
     *
     * @param aCode
     * @return
     */
    public boolean hasMatchingError(String aCode) {
        boolean retVal = false;
        for(int index = 0; index < messageList.size(); index++) {
            MessageDescriptor error = messageList.get(index);
            if(error.getSeverity().equals(MessageSeverityTypes.ERROR_TYPE_ERROR) && error.getCode().startsWith(aCode)) {
                retVal = true;
                break;
            }
        }
        return retVal;
    }

    /**
     * True if there has been a warning whose code starts with code `a_code'
     *
     * @param aCode
     * @return
     */
    public boolean hasMatchingWarning(String aCode) {
        boolean retVal = false;
        for(int index = 0; index < messageList.size(); index++) {
            MessageDescriptor error = messageList.get(index);
            if(error.getSeverity().equals(MessageSeverityTypes.ERROR_TYPE_WARNING) && error.getCode().startsWith(aCode)) {
                retVal = true;
                break;
            }
        }
        return retVal;
    }

    /**
     * Adds an error to this error cache and sets the error flag to true.
     *
     * @param aCode
     * @param args
     * @param aLocation
     */
    public void addError(String aCode, List<String> args, String aLocation) {
        add(new MessageDescriptor(aCode, MessageSeverityTypes.ERROR_TYPE_ERROR, messageDatabaseManager.getMessage(aCode, args), aLocation));
    }

    /**
     * Adds a warning to this error cache and sets the hasWarning flag to true.
     *
     * @param aCode
     * @param args
     * @param aLocation
     */
    public void addWarning(String aCode, List<String> args, String aLocation) {
        add(new MessageDescriptor(aCode, MessageSeverityTypes.ERROR_TYPE_WARNING, messageDatabaseManager.getMessage(aCode, args), aLocation));
    }

    /**
     * Adds a warning to this error cache and sets the hasInfo flag to true.
     *
     * @param aCode
     * @param args
     * @param aLocation
     */
    public void addInfo(String aCode, List<String> args, String aLocation) {
        add(new MessageDescriptor(aCode, MessageSeverityTypes.ERROR_TYPE_INFO, messageDatabaseManager.getMessage(aCode, args), aLocation));
    }

    /**
     * Adds a debug message to cache.
     *
     * @param aMessage
     * @param aLocation
     */
    public void addDebug(String aMessage, String aLocation) {
        add(new MessageDescriptor("", MessageSeverityTypes.ERROR_TYPE_DEBUG, aMessage, aLocation));
    }

    /**
     * Generic add method for adding a message of type debug, info, warning, or error to the cache.
     *
     * @param errorDescriptor
     */
    public void add(MessageDescriptor errorDescriptor) {
        messageList.add(errorDescriptor);
        hasErrors = hasErrors || errorDescriptor.getSeverity().equals(MessageSeverityTypes.ERROR_TYPE_ERROR);
        hasWarnings = hasWarnings || errorDescriptor.getSeverity().equals(MessageSeverityTypes.ERROR_TYPE_WARNING);
        hasInfo = hasInfo || errorDescriptor.getSeverity().equals(MessageSeverityTypes.ERROR_TYPE_INFO);
    }

    /**
     * Adds all items in the error cache of other onto this error cache.
     *
     * @param other
     */
    public void append(MessageLogger other) {
        this.messageList.addAll(other.getMessageList());
        hasErrors = hasErrors || other.hasErrors;
        hasWarnings = hasWarnings || other.hasWarnings;
        hasInfo = hasInfo || other.hasInfo;
    }

    /**
     * Clears the error message cache and resets all flags to false.
     *
     */
    public void clear() {
        messageList.clear();
        hasErrors = false;
        hasWarnings = false;
        hasInfo = false;
    }

    public List<MessageDescriptor> getMessageList() {
        return messageList;
    }

    /**
     * Generate stringified version of contents, with newlines inserted after each entry
     *
     * @return
     */
    public String toString() {
        StringBuilder builder = new StringBuilder();
        messageList.forEach(error -> {
            if(error.getSeverity() >= GlobalMessageLoggingLevel.getGlobalLoggingLevel()) {
                builder.append(error.toString()).append("\n");
            }
        });
        return builder.toString();
    }

    /**
     * Generate filtered stringified version of contents, with newlines inserted after each entry
     *
     * @param includeErrors
     * @param includeWarnings
     * @param includeInfo
     * @return
     */
    public String toStringFiltered(boolean includeErrors, boolean includeWarnings, boolean includeInfo) {
        StringBuilder builder = new StringBuilder();
        messageList.forEach(message -> {
            if(includeErrors && message.getSeverity().equals(MessageSeverityTypes.ERROR_TYPE_ERROR)) {
                builder.append(message.toString()).append("\n");
            } else if(includeWarnings && message.getSeverity().equals(MessageSeverityTypes.ERROR_TYPE_WARNING)) {
                builder.append(message.toString()).append("\n");
            } else if(includeInfo && message.getSeverity().equals(MessageSeverityTypes.ERROR_TYPE_INFO)) {
                builder.append(message.toString()).append("\n");
            }
        });
        return builder.toString();
    }

    /**
     * Returns the number of messages in this error cache.
     *
     * @return
     */
    public int size() {
        return messageList.size();
    }
}
